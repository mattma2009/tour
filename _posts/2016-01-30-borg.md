---
layout: post
title: Borg论文读书笔记
categories: [borg]
tags: [work]
---


### 简介 ###

Borg带来的三个好处：

1. 隐藏资源管理和故障处理细节，使其用户可以专注于应用开发；
1. 高可靠和高可用性；
1. 在线离线混部，提高使用效率。

### 负载 ###

Borg支持在线（web应用）和离线（批处理任务）两类任务，borg把这两类任务定义为prod job和non-opod job，在一个cell里面混部在线和离线任务是其提高资源利用率的关键。一个中等cell的规模在1w台机器，其中的机器很多是异构的。但是borg屏蔽了这些差异。另外，mapreduce类的也都是可以跑在borg上的。大多数borg的负载都没有跑在虚拟机上，因为虚拟化开销比较大。

关于task这块的描述有点像docker，做好镜像就不需要外部依赖，并且需要配置环境变量等信息。task在被kill掉之前要做些预备工作。关于优先级和配额控制，所有job都有优先级。

###Borg架构###

![](http://7fvil0.com1.z0.glb.clouddn.com/2016borg%2Fborg.jpg)

Borgmaster有两部分组成BorgMaster进程和scheduler。BorgMaster处理所有客户端的请求，其有多个副本，保证高可用性。并且会根据Paxos算法会选举出一个master处理变化。类似Zookeeper的方式。并且他还会保存某个时刻的checkpoint，为调试或者跟踪使用。

scheduler主要是处理task的，其会根据优先级决定任务是立即执行，还是要排队。在选择节点阶段他们用了一种叫做E-PVM的算法打分，但实践中发现会造成大量碎片。另外一种策略就是分得约满越好，也会有些问题。目前是一个混合模式。

另外一个问题是task的启动延迟，发现大部分时间消耗在安装，因此其在机器预装了大部分程序和包，和docker先获取并缓存基础镜像的思路是一致的。并且scheduler分发包的机制是基于树，并且采用BT协议，这样避免了网络带宽以及镜像服务器的压力。

Borglet是每台机器node上的代理程序，负责管理任务task，管理本机资源，日志以及汇报机器状态给master和其他监控系统。Borglet 消息的汇报通过 master 轮询 Borglet 来实现，这样 master 可以控制访问的速度，避免在特殊情况下踩踏事件的发生，毕竟及其规模太大了， push 的方式很可能会出问题。此外 master 的 replica 并不是单纯的做 backup 为了分担 master 的压力，每个 replica 会分担一部分的 Borglet 通信任务，再由 master 进行汇总。

如果 Borglet 几次没有响应轮询请求，将会被标记为挂了(down)，然后上面跑的 task 会被重新分配到其他机器。如果通讯恢复，Borgmaster 会让这个 Borglet 杀掉已经被分配出去的 task，来避免重复。

###高可用性###
Borg其高可用性的一些做法：

- 自动的重新调度被驱逐的 task，如果需要放到新机器上运行.
- 通过把一个 job 分散到不同的可用域里面去，例如机器、机架、供电域
- 在机器、OS 升级这些维护性工作时，降低在同一时刻的一个 job 中的 task 的关闭率
- 使用声明式的目标状态表示和幂等的状态改变做操作，这样故障的客户端可以无损的重新启动或安全的遗忘请求
- 对于失联的机器上的 task，限制一定的比率去重新调度，因为很难去区分大规模的机器故障和网络分区
- critical 级别的中间数据写到本地硬盘的日志保存 task 很重要，就算这个 task 所属的 alloc被终止或调度到其他机器上，也要恢复出来做。用户可以设置系统保持重复尝试多久.
- 就算 Borgmaster 或者 Borglet 挂了，task 也会继续运行下
去。不过，保持 master 运行也很重要，因为在它挂的时候新的 jobs 不能提交，或者结束的
无法更新状态，故障的机器上的 task 也不能重新调度。

总结：副本技术应对机器故障；管理控制应对超载；部署实例时用简单、底层的工具去减少外部依赖。每个 cell 和其他 cell 都是独立的，这样减少了误操作关联和故障传染。

###隔离性###

50%的机器跑 9 个以上的 task；最忙的 10%的机器大概跑 25 个 task，4500 个线程[83]。目前，所有 Borg task 都跑在 Linux cgroup-based 资源容器里面，Borglet 操作这些容器的设置，这样就增强了控制因为操作系统内核在起作用。

为了搞定超负荷和超请求，Borg task 有一个应用阶级(appclass)。最主要的区分在于latency-sensitive (LS)的应用和 batch类应用。LS task 是包括面向用户的应用和需要快速响应的共享基础设施。高优先级的 LS task 得到最高有待，可以为了这个把 batch task 一次饿个几秒种。

###相关工作###

提到了Mesos、YARN等一些工作，其实粗看感觉borg跟mesos还是比较接近，反而觉得kubernets中的目前没有针对批处理任务的做法。

###经验和教训

1. borg的分组机制设计的不好，在k8s采用pod+lable的方式。
2. 由于Linux namespace，pod 和 service 都可以有一个自己的 IP 地址。
3. pod的设计让相关容器被调度到一台机器。
4. 日志的统一管理，有助于问题的调试和发现。
5. 系统本身是一个分布式微服务架构，扩展能力更强。

###收获###

总体来说读此篇论文还是有不少收获，对我们PAAS平台的架构优化有不少帮助：

1. 是否考虑批处理任务的支持？目前以LS类应用为主要场景。
2. 其直接跑在物理机上，降低了虚拟化带来的开销。
3. 在线和离线任务的混部，提升资源利用率。
4. 资源调度算法，相对来说比较复杂，但确实给我一些启发。
5. 管理Master和调度schedule的分离，跟我们一致。
6. Master主动轮训borglet也跟我们一直，没采用Push的方式。
7. 打包和尽量缓存的机制跟docker镜像的理念基本一致。
8. 当borglet以及masterdown掉，不应该影响正在执行的task，也是应该的。

论文附件：[直接下载](http://7fvil0.com1.z0.glb.clouddn.com/2016borg%2FLarge-scale%20cluster%20management%20at%20Google%20with%20Borg.pdf)


